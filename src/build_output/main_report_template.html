<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nerpa Report</title>
     <style>
        /* General Table Styling */
        table {
            font-family: Arial, sans-serif;
            border-collapse: collapse;
            width: 100%;
        }

        th, td {
            border: 1px solid #dddddd;
            text-align: left;
            padding: 8px;
        }

        /* Input field and labels styling */
        input[type="text"] {
            padding: 8px;
            width: 33%; /* Set width to one-third of the page */
            box-sizing: border-box;
            margin-left: 10px; /* Add space between label and input */
        }

        label {
            font-weight: bold;
            display: inline-block; /* Keep label next to input */
            width: auto;
        }

        /* Filter and explanation sections */
        .filter-section {
            margin-bottom: 12px;
        }

        .explanation {
            margin-bottom: 12px;
            font-style: italic;
        }

        /* Align header text to the center, but align indicator to the right */
        th {
            text-align: center;
            cursor: pointer;
            background-color: #f2f2f2;
            position: relative; /* To position the indicator */
        }

        /* Indicator styling */
        th .indicator {
            position: absolute;
            right: 8px; /* Space from the right edge */
            top: 50%; /* Vertically center the indicator */
            transform: translateY(-50%); /* Adjust for exact vertical centering */
            visibility: hidden; /* Initially hidden */
            font-weight: bold; /* Bold indicator */
        }

        /* Align Match ID and Score columns to the right */
        td.match-id, td.score {
            text-align: right;
        }

        /* Alternate row colors */
        tbody tr:nth-child(odd) {
            background-color: #ffffff;
        }

        tbody tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        /* Hover effect for rows */
        tbody tr:hover {
            background-color: #e6f7ff;
        }
    </style>
</head>
<body>
    <script src="{{HTML_AUX_DIR}}/report_data.js"></script>

    <h1>Nerpa main report</h1>

    <!-- Filter Input Fields -->
    <div class="filter-section">
        <label for="nrpFilterInput">Filter by NRP</label>
        <input type="text" id="nrpFilterInput" placeholder="Enter NRP_ID to filter...">
    </div>

    <div class="filter-section">
        <label for="genomeFilterInput">Filter by Genome</label>
        <input type="text" id="genomeFilterInput" placeholder="Enter Genome_ID to filter...">
    </div>

    <!-- Explanation for sorting -->
    <div class="explanation">
        Click a column name to sort the rows; click again to toggle the sort direction (▲/▼). Click a Match ID to open the detailed match report.
    </div>

    <table id="reportTable">
        <thead>
            <tr>
                <th>Match ID</th>
                <th>Score</th>
                <th>NRP</th>
                <th>Genome</th>
                <th>BGC ID</th>
            </tr>
        </thead>
        <tbody>
            <!-- Rows will be populated here by JavaScript -->
        </tbody>
    </table>

    <script>
        // Function to detect if a value is numeric
        function isNumeric(value) {
            return !isNaN(parseFloat(value)) && isFinite(value);
        }
        
        // Detect column indices by header names
        const columnIndices = {};
        const headers = document.querySelectorAll('#reportTable th');

        headers.forEach((header, index) => {
            const headerText = header.textContent.trim();
            if (headerText === 'Score') {
                columnIndices.score = index;
            } else if (headerText === 'Match ID') {
                columnIndices.matchID = index;
            } else if (headerText === 'NRP') {
                columnIndices.nrp = index;
            } else if (headerText === 'Genome') {
                columnIndices.genome = index;
            }
        });

        // Populate table with rounded scores and right-aligned columns
        function populateTable(data) {
            const tableBody = document.querySelector('#reportTable tbody');
            tableBody.innerHTML = '';

            if (data && Array.isArray(data)) {
                data.forEach(item => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td class="match-id"><a href="{{HTML_AUX_DIR}}/match_${item.Match_ID}.html">${item.Match_ID}</a></td>
                        <td class="score">${parseFloat(item.Score).toFixed(2)}</td>
                        <td>${item.NRP}</td>
                        <td>${item.Genome}</td>
                        <td>${item.BGC}</td>
                    `;
                    tableBody.appendChild(row);
                });
            } else {
                console.error('Invalid data structure: Results array not found');
            }
        }

        // Function to sort table by column with toggleable sorting direction
        function sortTable(n) {
            const table = document.getElementById("reportTable");
            const headers = table.querySelectorAll("th");
            const rows = Array.from(table.querySelectorAll("tbody tr"));
            let dir = headers[n].dataset.sortDirection === "asc" ? "desc" : "asc"; // Toggle direction

            // Store the new sort direction in the clicked header
            headers.forEach(header => header.dataset.sortDirection = ""); // Reset directions
            headers[n].dataset.sortDirection = dir; // Set new direction for clicked column

            // Hide all indicators first
            headers.forEach(header => {
                const indicator = header.querySelector('.indicator');
                if (indicator) {
                    indicator.style.visibility = 'hidden'; // Hide all indicators
                }
            });

            // Show the indicator for the clicked column
            const clickedHeader = headers[n];
            const indicator = clickedHeader.querySelector('.indicator');
            if (indicator) {
                indicator.style.visibility = 'visible'; // Show the indicator
                indicator.textContent = dir === 'asc' ? '▲' : '▼'; // Set the appropriate indicator (▲ for asc, ▼ for desc)
            }

            // Sort rows based on the direction and column index
            rows.sort((a, b) => {
                const x = a.getElementsByTagName("TD")[n].textContent.trim();
                const y = b.getElementsByTagName("TD")[n].textContent.trim();

                if (isNumeric(x) && isNumeric(y)) {
                    return dir === "asc" ? x - y : y - x;
                } else {
                    return dir === "asc" ? x.localeCompare(y) : y.localeCompare(x);
                }
            });

            // Append sorted rows to the table body
            const tbody = table.querySelector("tbody");
            tbody.innerHTML = ''; // Clear current rows
            rows.forEach(row => tbody.appendChild(row)); // Append sorted rows
        }

        // Event listener for sortable columns with initial setup for "Score" column
        document.addEventListener('DOMContentLoaded', function () {
            const headers = document.querySelectorAll("#reportTable th");
            headers.forEach((header, index) => {
                // Set initial sorting direction for "Score" column to "desc"
                header.dataset.sortDirection = (index === columnIndices.score) ? "desc" : "";

                // Add event listener for sorting
                header.addEventListener("click", function () {
                    sortTable(index);
                });

                // Create an indicator element for each header
                const indicator = document.createElement('span');
                indicator.classList.add('indicator');
                header.appendChild(indicator);
            });

            // Ensure the indicator for the "Score" column is visible initially with "desc" direction
            const scoreHeader = headers[columnIndices.score];
            const scoreIndicator = scoreHeader.querySelector('.indicator');
            if (scoreIndicator) {
                scoreIndicator.style.visibility = 'visible'; // Show the indicator for "Score"
                scoreIndicator.textContent = '▼'; // Set "Score" to descending initially
            }
        });

        populateTable(data);

        // Function to filter the table based on NRP_ID and Genome_ID
        function filterTable() {
            const nrpIndex = columnIndices.nrp; // Use columnIndices for NRP
            const genomeIndex = columnIndices.genome; // Use columnIndices for Genome
            const nrpInput = document.getElementById("nrpFilterInput");
            const genomeInput = document.getElementById("genomeFilterInput");
            const nrpFilter = nrpInput.value.toLowerCase();
            const genomeFilter = genomeInput.value.toLowerCase();
            const table = document.getElementById("reportTable");
            const tr = table.getElementsByTagName("tr");
            const headers = table.getElementsByTagName("th");

            for (let i = 1; i < tr.length; i++) {
                let showRow = true; // Start by assuming the row should be shown
                const nrpTd = tr[i].getElementsByTagName("td")[nrpIndex]; // Get NRP_ID column dynamically
                const genomeTd = tr[i].getElementsByTagName("td")[genomeIndex]; // Get Genome_ID column dynamically

                if (nrpTd) {
                    const nrpValue = nrpTd.textContent || nrpTd.innerText;
                    if (nrpFilter && nrpValue.toLowerCase().indexOf(nrpFilter) === -1) {
                        showRow = false; // Hide row if NRP_ID does not match
                    }
                }

                if (genomeTd) {
                    const genomeValue = genomeTd.textContent || genomeTd.innerText;
                    if (genomeFilter && genomeValue.toLowerCase().indexOf(genomeFilter) === -1) {
                        showRow = false; // Hide row if Genome_ID does not match
                    }
                }

                // Show or hide the row based on the filter results
                tr[i].style.display = showRow ? "" : "none";
            }
        }

        // Event listeners for filter inputs
        document.getElementById("nrpFilterInput").addEventListener("keyup", filterTable);
        document.getElementById("genomeFilterInput").addEventListener("keyup", filterTable);
    </script>
</body>
</html>
