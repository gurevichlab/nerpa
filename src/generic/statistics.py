from typing import Dict, List, Tuple, TypeVar
import numpy as np
from itertools import combinations

T = TypeVar('T', int, float)


# TODO: generated by ChatGPT, don't know how reasonable this is
def filter_outliers(data: List[T]) -> List[T]:
    # Step 1: Compute Q1, Q3, and IQR
    Q1 = np.percentile(data, 25)
    Q3 = np.percentile(data, 75)
    IQR = Q3 - Q1

    # Step 2: Define outlier boundaries
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    # Step 3: Filter out outliers
    filtered_data = [x for x in data if lower_bound <= x <= upper_bound]

    return filtered_data



def fit_between_lines(data: Dict[float, List[float]],
                      allowed_omit_fraction: float = 0) -> Tuple[float, float, float]:
    '''
    Returns (slope, intercept, margin), such that
     at least 1-allowed_omit_fraction of points lie between the lines
     y = slope * x + intercept +- offset
    '''
    points = [(x, y)
              for x, ys in sorted(data.items())
              for y in filter_outliers(ys)]

    # q: fit a line to the points
    # Extract x and y coordinates from points
    x_coords = [p[0] for p in points]
    y_coords = [p[1] for p in points]

    # Fit a line using polyfit (degree=1 for a linear fit)
    slope, intercept = np.polyfit(x_coords, y_coords, 1)

    def dist_to_line(x: float, y: float) -> float:  # this is not distance but is proportional to it
        return abs(y - (slope * x + intercept))

    sorted_points = sorted(points, key=lambda p: dist_to_line(*p))
    num_points_to_omit = int(len(sorted_points) * allowed_omit_fraction)

    farthest_point = sorted_points[-num_points_to_omit - 1]

    eps = 1e-6
    margin = abs(farthest_point[1] - slope * farthest_point[0] - intercept) + eps
    return slope, intercept, margin